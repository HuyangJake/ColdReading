---
title: iOS应用性能优化小记
date: 2017-11-25 22:49:44
tags: [iOS, 动画]
categories: 猿猿养成记
---
性能，移动应用最直观的体验就是界面是否流畅。在编程过程中大家或多或少总有遇到过关于提高应用性能的操作，比如简单的“异步线程加载图片”，“圆角绘制优化”，“懒加载视图”，“缓存图片”，“避免日期格式转换”等等，都是在把耗时耗资源的操作分散到其他时机执行，或者避免执行。也就是让UI主线程只执行轻量的任务以保证界面的流畅。而本文要讲的是只能在主线程中执行的动画性能的优化。

动画过程是流畅对最直观的体现，而动画效果对设备的硬件资源有一定的要求。针对现代iOS设备来说，造成应用性能的下降在于资源的过度消耗。这里的“资源”指的是什么呢？
<!--more-->
### CPU & GPU
关于绘图和动画有两种处理的方式：CPU（中央处理器）和GPU（图形处理器）。在现代iOS设备中，都有可以运行不同软件的可编程芯片，但是由于历史原 因，我们可以说CPU所做的工作都在软件层面，而GPU在硬件层面。
总的来说，我们可以用软件（使用CPU）做任何事情，但是对于图像处理，通常 用硬件会更快，因为GPU使用图像对高度并行浮点运算做了优化。由于某些原因， 我们想尽可能把屏幕渲染的工作交给硬件去处理。问题在于GPU并没有无限制处理 性能，而且一旦资源用完的话，性能就会开始下降了（即使CPU并没有完全占用）

__大多数动画性能优化都是关于智能利用GPU和CPU，使得它们都不会超出负荷。__ 于是我们首先需要知道Core Animation是如何在这两个处理器之间分配工作的。

#### 一段动画的六个阶段（延伸阅读）
其实iOS系统中到处充满着动画，双击Home键出来了应用切换界面、下拉出现通知中心，打开任何App时过程，都是动画在装饰着这些操作。还有在编程的时候，任意的UIView动画都默认包含着Core Animation实现的0.25秒的隐式动画。Core Animation 处在iOS的核心地位。
当运行一段动画的时，这个过程会被分离为四个阶段：

1. 布局 - 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景 色，边框等等）的阶段
2. 显示 - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的`-drawReact:` 和 `drawLayer:inContext:`方法的调用路径。
3. 准备 - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是 Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的 时间点。
4. 提交 - 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过 IPC（内部处理通信）发送到渲染服务进行显示。

上面的阶段只是发生在我们的应用程序内，在动画展示早屏幕上之前还有更多的操作。一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形 成另一个叫做渲染树的图层树。使用这个树状结 构，渲染服务对动画的每一帧做出如下工作：

* 对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染
* 在屏幕上渲染可见的三角形 

所以一共有6个阶段，最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，我们真正能控制的只是前两个阶段，布局和显示。剩下的都由Core Animation框架在内部处理，我们控制不了。不过这并没有什么影响，在布局和显示阶段，我们就可以决定哪些由CPU执行，哪些交给GPU执行。

#### GPU
GPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变 换，应用纹理和混合然后把它们输送到屏幕上。大多数的`CALayer`的属性都是GPU来绘制的。下面几项操作会降低基于GPU的图层绘制：

* __太多的几何结构__ - 这发生在需要太多的三角板来做变换，以应对处理器的栅格 化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对 象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数

* __重绘__ - 主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比 率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。 在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达 2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整 屏的冗余信息，而不影响性能），并且新设备可以处理更多。

* __离屏绘制__ - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上 下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图 片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图 层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效 果，只是要明白这会带来性能的负面影响。

* __过大的图片__ - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的 纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性 能。

#### CPU
大多数工作在Core Animation的CPU都发生在动画开始之前。但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。

以下的CPU操作都会延迟动画的开始时间：

* 布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图 层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应 该是比老版的自动调整逻辑加强了CPU的工作。

* 视图懒加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对 内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致 的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图 从一个nib文件中加载，或者涉及IO的图片显示（见后续“IO相关操作”），都会 比CPU正常操作慢得多。

* Core Graphics绘制 - 如果对视图实现了`-drawReact:`方法，或者 `-drawLayer:inContext:`方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后， 必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就 会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。

* 解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同 于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去 解码图片（14章“图片IO”会更详细讨论）。根据你加载图片的方式，第一次对 图层内容赋值的时候（直接或者间接使用`UIImageView`）或者把它绘制到 Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会 占用一定的时间。

当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示 屏幕上的图层，Core Animation必须对渲染树种的每个可见图层通过OpenGL循环 转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须 要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层 级关系中有太多的图层，就会导致CPU没一帧的渲染，即使这些事情不是你的应用程序可控的。



### Reference

*《iOS核心动画》性能调优*


